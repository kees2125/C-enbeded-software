<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Nut/OS API</title>
    <link href="nut_en.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>Banked Memory<br>
<small>
[<a class="el" href="group__xgAppSugar.html">Application Candies</a>]</small>
</h1>
<p>
Collaboration diagram for Banked Memory:<center><table><tr><td><img src="group__xgBankMem.png" border="0" alt="" usemap="#group____xgBankMem_map">
<map name="group____xgBankMem_map">
<area href="group__xgAppSugar.html" shape="rect" coords="19,5,147,26" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Banked RAM support. 
<p>
Even with a hardware decoder like the one used on the Medianut Board, streaming MP3 data in realtime from a TCP/IP network to the decoder requires some special techniques to make it work on a tiny 8 bit system.<p>
The key to success is avoidance of data copying. Usually data streams are moved from the Ethernet Controller to the Ethernet's driver buffer, then moved to the TCP buffer, again moved to the application buffer and finally from the application buffer to the MP3 decoder buffer. Some systems may use additional steps. Nut/OS tries to avoid these copies. In extreme, the data may be moved directly from the Ethernet controller to the MP3 controller. In reality this will fail, because TCP isn't realtime, but playing MP3 is. So at least one buffer stage is required to compensate the non deterministic arrival of TCP data. Each packet received is moved from the Ethernet controller into a so called NETBUF. Each NETBUF is added to a connection specific queue until the application request data from the connection. For portability reasons and to keep things simple, the application provides a buffer and calls <a class="el" href="group__xgTcpSocket.html#ga13">NutTcpReceive()</a> to get that buffer filled with application data out of the queued NETBUFs. This is another copy, but frees the application from dealing with system specific NETBUF structures.<p>
The smart part is, that Nut/OS offers a special buffer management to avoid the final copy into the decoder buffer and that the Nut/OS MP3 decoder driver makes use of this buffer management. As stated, normally the application buffer is filled by some kind of read statement (first copy) and transfered to the driver by some kind of write statement (second copy).<p>
When using the segmented memory management, the application will query the driver for buffer space first and then pass this buffer to the TCP read routine. This way the TCP read routine will directly fill the buffer of the decoder driver. When this has been done, the application commits the buffer filled and requests a new one and so on.<p>
Finally the segmented memory mamagement API can not only handle a continuos memory space, but also one that is divided into several segments. This is usefull with banked memory hardware provided by Ethernut 2 boards.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>At least some parts should be moved to the device section. </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgBankMem.html#ga9">NutSegBufReset</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the segmented buffer.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgBankMem.html#ga10">NutSegBufInit</a> (size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the segmented buffer.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgBankMem.html#ga11">NutSegBufWriteRequest</a> (size_t *bcp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request segmented buffer space for writing.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgBankMem.html#ga12">NutSegBufReadRequest</a> (size_t *bcp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request segmented buffer space for reading.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgBankMem.html#ga13">NutSegBufWriteCommit</a> (size_t bc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit written buffer space.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgBankMem.html#ga14">NutSegBufReadCommit</a> (size_t bc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit read buffer space.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgBankMem.html#ga15">NutSegBufWriteLast</a> (size_t bc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit written buffer space and finish write access.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgBankMem.html#ga16">NutSegBufReadLast</a> (size_t bc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit written buffer space and finish read access.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__xgNutOS.html#ga3">u_long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgBankMem.html#ga17">NutSegBufAvailable</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the available buffer space.  <a href="#ga17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__xgNutOS.html#ga3">u_long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgBankMem.html#ga18">NutSegBufUsed</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the used buffer space.  <a href="#ga18"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga9"></a><!-- doxytag: member="bankmem.c::NutSegBufReset" ref="ga9" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">char* NutSegBufReset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset the segmented buffer. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the first buffer segment.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10"></a><!-- doxytag: member="bankmem.c::NutSegBufInit" ref="ga10" args="(size_t size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">char* NutSegBufInit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the segmented buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Number of bytes to allocate for the global buffer. In systems with banked memory this parameter is ignored and all banked memory is occupied for the global buffer. In systems without banked memory, the specified number of bytes is taken from heap memory.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the first buffer segment or null on failures.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11"></a><!-- doxytag: member="bankmem.c::NutSegBufWriteRequest" ref="ga11" args="(size_t *bcp)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">char* NutSegBufWriteRequest           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bcp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request segmented buffer space for writing. 
<p>
This call will also enable the current write segment and may disable the current read segment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bcp</em>&nbsp;</td><td>Pointer to a variable, which receives the number of consecutive bytes available for writing.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the next write position.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12"></a><!-- doxytag: member="bankmem.c::NutSegBufReadRequest" ref="ga12" args="(size_t *bcp)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">char* NutSegBufReadRequest           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bcp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request segmented buffer space for reading. 
<p>
This call will also enable the current read segment and may disable the current write segment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bcp</em>&nbsp;</td><td>Pointer to a variable, which receives the number of consecutive bytes available for reading.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the next read position.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13"></a><!-- doxytag: member="bankmem.c::NutSegBufWriteCommit" ref="ga13" args="(size_t bc)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">char* NutSegBufWriteCommit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Commit written buffer space. 
<p>
The write pointer will be incremented by the specified number of bytes. If the pointer reaches the end of a segment, the next segment will be enabled and the pointer will point to the start of the new segement.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bc</em>&nbsp;</td><td>Number of bytes to commit.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the next write position.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14"></a><!-- doxytag: member="bankmem.c::NutSegBufReadCommit" ref="ga14" args="(size_t bc)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">char* NutSegBufReadCommit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Commit read buffer space. 
<p>
The read pointer will be incremented by the specified number of bytes. If the pointer reaches the end of a segment, the next segment will be enabled and the pointer will point to the start of the new segement.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bc</em>&nbsp;</td><td>Number of bytes to commit.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the next read position.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15"></a><!-- doxytag: member="bankmem.c::NutSegBufWriteLast" ref="ga15" args="(size_t bc)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutSegBufWriteLast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Commit written buffer space and finish write access. 
<p>
The write pointer will be incremented by the specified number of bytes. This call will also enable the current read segment and may disable the current write segment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bc</em>&nbsp;</td><td>Number of bytes to commit.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16"></a><!-- doxytag: member="bankmem.c::NutSegBufReadLast" ref="ga16" args="(size_t bc)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutSegBufReadLast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Commit written buffer space and finish read access. 
<p>
The write pointer will be incremented by the specified number of bytes. This call will also enable the current read segment and may disable the current write segment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bc</em>&nbsp;</td><td>Number of bytes to commit.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga17"></a><!-- doxytag: member="bankmem.c::NutSegBufAvailable" ref="ga17" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__xgNutOS.html#ga3">u_long</a> NutSegBufAvailable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the available buffer space. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Total number of free bytes in the buffer.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga18"></a><!-- doxytag: member="bankmem.c::NutSegBufUsed" ref="ga18" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__xgNutOS.html#ga3">u_long</a> NutSegBufUsed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the used buffer space. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Total number of used bytes in the buffer.</dd></dl>
    </td>
  </tr>
</table>
<hr>
<address>
  <small>
    &copy;&nbsp;2000-2006 by egnite Software GmbH - 
    visit <a href="http://www.ethernut.de/">http://www.ethernut.de/</a>
  </small>
</address>
</body>
</html>
