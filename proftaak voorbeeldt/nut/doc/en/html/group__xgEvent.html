<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Nut/OS API</title>
    <link href="nut_en.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>Event Management<br>
<small>
[<a class="el" href="group__xgNutOS.html">Nut/OS API</a>]</small>
</h1>
<p>
Collaboration diagram for Event Management:<center><table><tr><td><img src="group__xgEvent.png" border="0" alt="" usemap="#group____xgEvent_map">
<map name="group____xgEvent_map">
<area href="group__xgNutOS.html" shape="rect" coords="17,5,95,26" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Thread synchronization support. 
<p>
Threads may wait for events from other threads or interrupts or may post or broadcast events to other threads.<p>
Waiting threads line up in priority ordered queues, so more than one thread may wait for the same event. A waiting queue is a simple linked list of waiting threads.<p>
Events are posted to a waiting queue, moving the <a class="el" href="group__xgThread.html#xrThread">thread</a> from waiting (sleeping) state to ready-to-run state. A running thread may also broadcast an event to a specified queue, waking up all threads on that queue.<p>
Usually a woken up thread takes over the CPU, if it's priority is equal or higher than the currently running thread. However, events can be posted asynchronously, in which case the posting thread continues to run.<p>
Interrupt can also post events, but have to use the specific function <a class="el" href="group__xgEvent.html#ga9">NutEventPostFromIrq()</a>.
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgEvent.html#ga7">SIGNALED</a>&nbsp;&nbsp;&nbsp;((void *)-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signaled state definition.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgEvent.html#ga8">NUT_WAIT_INFINITE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Infinite waiting time definition.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgEvent.html#ga9">NutEventPostFromIrq</a>(qp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post an event to a specified queue from interrupt context.  <a href="#ga9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgEvent.html#ga0">NutEventTimeout</a> (<a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> timer, void *arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Timer callback in case of event timeout.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgEvent.html#ga1">NutEventWait</a> (volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *qhp, <a class="el" href="group__xgNutOS.html#ga3">u_long</a> ms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for an event in a specified queue.  <a href="#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgEvent.html#ga2">NutEventWaitNext</a> (volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *qhp, <a class="el" href="group__xgNutOS.html#ga3">u_long</a> ms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a new event in a specified queue.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgEvent.html#ga3">NutEventPostAsync</a> (volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *qhp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronously post an event to a specified queue.  <a href="#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgEvent.html#ga4">NutEventPost</a> (volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *qhp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post an event to a specified queue.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgEvent.html#ga5">NutEventBroadcastAsync</a> (volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *qhp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronously broadcast an event to a specified queue.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgEvent.html#ga6">NutEventBroadcast</a> (volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *qhp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broadcast an event to a specified queue.  <a href="#ga6"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ga7"></a><!-- doxytag: member="event.h::SIGNALED" ref="ga7" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define SIGNALED&nbsp;&nbsp;&nbsp;((void *)-1)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signaled state definition. 
<p>
The root of an event queue is set to this value if an event is posted to an empty queue. As this may happen during interrupts, the root of an event queue must be considered volatile.<p>
Timer handles in the THREADINFO structure are set to this value if a timeout occured while waiting for an event.    </td>
  </tr>
</table>
<a class="anchor" name="ga8"></a><!-- doxytag: member="event.h::NUT_WAIT_INFINITE" ref="ga8" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define NUT_WAIT_INFINITE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Infinite waiting time definition. 
<p>
Applications should use this value to disable timeout monitoring while waiting for an event.    </td>
  </tr>
</table>
<a class="anchor" name="ga9"></a><!-- doxytag: member="event.h::NutEventPostFromIrq" ref="ga9" args="(qp)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define NutEventPostFromIrq          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">qp&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{                                   \
    <span class="keywordflow">if</span> (*qp == 0) {                 \
        *qp = <a class="code" href="group__xgEvent.html#ga7">SIGNALED</a>;             \
    }                               \
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*qp != <a class="code" href="group__xgEvent.html#ga7">SIGNALED</a>) {     \
        <a class="code" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *tp = (<a class="code" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *)(*qp);    \
        tp-&gt;<a class="code" href="struct__NUTTHREADINFO.html#o2">td_qpec</a>++;              \
    }                               \
}
</pre></div>Post an event to a specified queue from interrupt context. 
<p>
Wake up the thread with the highest priority waiting on the specified queue. This function is explicitly provided for IRQ handlers to wakeup waiting user threads.<p>
Internally a counter is used to keep track of the posted events. This counter will be examined when the currently running thread is ready to release the CPU.<p>
<dl compact><dt><b>Note:</b></dt><dd>When calling this function, interrupt routines will change the root of an empty event queue to SIGNALED.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qp</em>&nbsp;</td><td>Identifies the queue an event is posted to.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga0"></a><!-- doxytag: member="event.c::NutEventTimeout" ref="ga0" args="(HANDLE timer, void *arg)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutEventTimeout           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__xgNutOS.html#ga5">HANDLE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>arg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Timer callback in case of event timeout. 
<p>
Applications should not call this function. It is provided as a global to enable debugging code inspecting the callbacks in the timer list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>Handle of the elapsed timeout timer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Handle of an event queue.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1"></a><!-- doxytag: member="event.c::NutEventWait" ref="ga1" args="(volatile HANDLE *qhp, u_long ms)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutEventWait           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>qhp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__xgNutOS.html#ga3">u_long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ms</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for an event in a specified queue. 
<p>
Give up the CPU until another thread or an interrupt routine posts an event to this queue or until a time-out occurs, whichever comes first.<p>
If previously an event had been posted to this queue without any thread waiting, then the thread will not wait for a new event, but may still pass CPU control, if another thread with equal or higher priority is ready to run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue to wait on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms</em>&nbsp;</td><td>Maximum wait time in milliseconds. To disable timeout, set this parameter to NUT_WAIT_INFINITE.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if event received, -1 on timeout.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Timeout is limited to the granularity of the system timer.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2"></a><!-- doxytag: member="event.c::NutEventWaitNext" ref="ga2" args="(volatile HANDLE *qhp, u_long ms)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutEventWaitNext           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>qhp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__xgNutOS.html#ga3">u_long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ms</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for a new event in a specified queue. 
<p>
Give up the CPU until another thread or an interrupt routine posts an event to this queue or until a time-out occurs, whichever comes first.<p>
This call is similar to <a class="el" href="group__xgEvent.html#ga1">NutEventWait()</a>, but will ignore the SIGNALED state of the queue. This way, previously posted events to an empty queue are not considered.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue to wait on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms</em>&nbsp;</td><td>Maximum wait time in milliseconds. To disable timeout, set this parameter to NUT_WAIT_INFINITE.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if event received, -1 on timeout.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Timeout is limited to the granularity of the system timer.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3"></a><!-- doxytag: member="event.c::NutEventPostAsync" ref="ga3" args="(volatile HANDLE *qhp)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutEventPostAsync           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>qhp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Asynchronously post an event to a specified queue. 
<p>
Wake up the thread with the highest priority waiting on the specified queue. But even if the priority of the woken thread is higher than the current thread's priority, the current one continues running.<p>
If no thread is waiting, then the queue will be set to the SIGNALED state.<p>
<dl compact><dt><b>Note:</b></dt><dd>Interrupts must not call this function but use <a class="el" href="group__xgEvent.html#ga9">NutEventPostFromIrq()</a> to post events to specific queues.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue an event is posted to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of threads woken up, either 0 or 1.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4"></a><!-- doxytag: member="event.c::NutEventPost" ref="ga4" args="(volatile HANDLE *qhp)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutEventPost           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>qhp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Post an event to a specified queue. 
<p>
Wake up the thread with the highest priority waiting on this queue. If the priority of the waiting thread is higher or equal than the current thread's priority, then the current thread is stopped and CPU control is passed to the waiting thread.<p>
If no thread is waiting, the queue will be set to the signaled state.<p>
<dl compact><dt><b>Note:</b></dt><dd>Interrupts must not call this function but use <a class="el" href="group__xgEvent.html#ga9">NutEventPostFromIrq()</a> to post events to specific queues.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue an event is posted to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of threads woken up, either 0 or 1.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5"></a><!-- doxytag: member="event.c::NutEventBroadcastAsync" ref="ga5" args="(volatile HANDLE *qhp)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutEventBroadcastAsync           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>qhp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Asynchronously broadcast an event to a specified queue. 
<p>
Wake up all threads waiting on this queue. But even if the priority of any woken thread is higher than the current thread's priority, the current one continues running.<p>
In opposite to <a class="el" href="group__xgEvent.html#ga3">NutEventPostAsync()</a>, the queue will be cleared in any case, even if it is in signaled state. Applications may use this call to make sure, that a queue is cleared before initiating some event triggering action.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue an event is broadcasted to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of threads woken up.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6"></a><!-- doxytag: member="event.c::NutEventBroadcast" ref="ga6" args="(volatile HANDLE *qhp)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutEventBroadcast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">volatile <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>qhp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Broadcast an event to a specified queue. 
<p>
Wake up all threads waiting on this queue. If the priority of any waiting thread is higher or equal than the current thread's priority, then the current thread is stopped and CPU control is passed to the woken up thread with the highest priority.<p>
In opposite to <a class="el" href="group__xgEvent.html#ga4">NutEventPost()</a>, the queue will be cleared in any case, even if it is in signaled state. Applications may use this call to make sure, that a queue is cleared before initiating some event triggering action.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue an event is broadcasted to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of threads woken up.</dd></dl>
    </td>
  </tr>
</table>
<hr>
<address>
  <small>
    &copy;&nbsp;2000-2006 by egnite Software GmbH - 
    visit <a href="http://www.ethernut.de/">http://www.ethernut.de/</a>
  </small>
</address>
</body>
</html>
