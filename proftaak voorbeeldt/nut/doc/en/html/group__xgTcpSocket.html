<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Nut/OS API</title>
    <link href="nut_en.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>TCP Sockets<br>
<small>
[<a class="el" href="group__xgNutNet.html">Nut/Net API</a>,&nbsp;<a class="el" href="group__xgSocket.html">Socket API</a>]</small>
</h1>
<p>
Collaboration diagram for TCP Sockets:<center><table><tr><td><img src="group__xgTcpSocket.png" border="0" alt="" usemap="#group____xgTcpSocket_map">
<map name="group____xgTcpSocket_map">
<area href="group__xgNutNet.html" shape="rect" coords="19,6,96,27" alt="">
<area href="group__xgSocket.html" shape="rect" coords="20,51,95,72" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Application interface for TCP sockets. 
<p>
TCP clients typically use this order of API calls<ul>
<li><a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a></li><li><a class="el" href="group__xgTcpSocket.html#ga10">NutTcpConnect()</a></li><li><a class="el" href="group__xgTcpSocket.html#ga12">NutTcpSend()</a>, <a class="el" href="group__xgTcpSocket.html#ga13">NutTcpReceive()</a></li><li><a class="el" href="group__xgTcpSocket.html#ga14">NutTcpCloseSocket()</a></li></ul>
<p>
This is quite similar to the traditional Berkley TCP Socket API used on desktop PCs.<p>
The order of API calls for TCP servers is<ul>
<li><a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a></li><li><a class="el" href="group__xgTcpSocket.html#ga11">NutTcpAccept()</a></li><li><a class="el" href="group__xgTcpSocket.html#ga12">NutTcpSend()</a>, <a class="el" href="group__xgTcpSocket.html#ga13">NutTcpReceive()</a></li><li><a class="el" href="group__xgTcpSocket.html#ga14">NutTcpCloseSocket()</a></li></ul>
<p>
Note, that this differs slightly from the Berkley API, where the initial socket is bound to a port and an additional socket is created when a connection is accepted. Nut/Net doesn't provide a bind call.<p>
Most Nut/OS applications make use of the ability to assign a TCP socket to a stream and replace the somewhat primitive functions <a class="el" href="group__xgTcpSocket.html#ga12">NutTcpSend()</a> and <a class="el" href="group__xgTcpSocket.html#ga13">NutTcpReceive()</a> with stdio calls like <a class="el" href="group__xgCrtStdio.html#ga18">fprintf()</a> or <a class="el" href="group__xgCrtStdio.html#ga26">fscanf()</a>. <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="socket_8h.html">sys/socket.h</a>&gt;</span>

 ...

 <a class="code" href="structtcp__socket.html">TCPSOCKET</a> *sock;
 <a class="code" href="group__xgCrtStdio.html#ga0">FILE</a> *stream;

 ...

 stream = <a class="code" href="group__xgCrtStdio.html#ga8">_fdopen</a>((<span class="keywordtype">int</span>) sock, <span class="stringliteral">"r+b"</span>);
 <a class="code" href="group__xgCrtStdio.html#ga18">fprintf</a>(stream, <span class="stringliteral">"Hello peer\r\n"</span>);
</pre></div><p>
Remember, that Nut/OS streams are opened in text mode by default. Thus, we explicitly specify binary mode for the stream.<p>
The application programmer can modify some default values of the TCP stack by calling <a class="el" href="group__xgTcpSocket.html#ga8">NutTcpSetSockOpt()</a>. This could be useful to fine tune the stack for maximum performance at minimum resource usage.<p>
In addition you may call <a class="el" href="group__xgTcpSocket.html#ga8">NutTcpSetSockOpt()</a> to set a receive timeout in order to detect broken connections. That's often required, because TCP relies on a gracefully closed connection on the remote side. If the remote crashes or if the physical connection breaks, then <a class="el" href="group__xgTcpSocket.html#ga13">NutTcpReceive()</a> will never return unless a receive timeout value had been set. At least this is true for Nut/Net, which currently doesn't support the <a class="el" href="socket_8h.html#a6">SO_KEEPALIVE</a> option.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="socket_8h.html">sys/socket.h</a>&gt;</span>

 ...

 <a class="code" href="structudp__socket.html">UDPSOCKET</a> *sock;
 <a class="code" href="group__xgNutOS.html#ga3">u_long</a> tmo = 3000;
 <span class="keywordtype">int</span> rc;
 <span class="keywordtype">char</span> buff[128];

 ...

 <a class="code" href="group__xgTcpSocket.html#ga8">NutTcpSetSockOpt</a>(sock, <a class="code" href="socket_8h.html#a18">SO_RCVTIMEO</a>, &amp;tmo, <span class="keyword">sizeof</span>(tmo));

 ...

 rc = <a class="code" href="group__xgTcpSocket.html#ga13">NutTcpReceive</a>(sock, buff, <span class="keyword">sizeof</span>(buf));
 <span class="keywordflow">if</span> (rc == 0) {
      
      * A timeout occured. We will now perform an application specific
      * action to check wether our remote is still alive.
      
 ...

 }
</pre></div><p>
Note again the difference to the Berkley API, where select() is used to determine receive timeouts.<p>
Most socket API calls return -1 in case of a failure. The function <a class="el" href="group__xgTcpSocket.html#ga15">NutTcpError()</a> can be used to query a more specific error code. <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="socket_8h.html">sys/socket.h</a>&gt;</span>

 ...

 <a class="code" href="structtcp__socket.html">TCPSOCKET</a> *sock;
 <a class="code" href="group__xgNutOS.html#ga3">u_long</a> <a class="code" href="structip.html">ip</a> = <a class="code" href="group__xgIP.html#ga8">inet_addr</a>(<span class="stringliteral">"192.168.1.100"</span>);
 <a class="code" href="group__xgNutOS.html#ga1">u_short</a> port = 20191;
 <span class="keywordtype">int</span> tcperr;

 ...

 <span class="keywordflow">if</span> (<a class="code" href="group__xgTcpSocket.html#ga10">NutTcpConnect</a>(sock, ip, port)) {
     tcperr = <a class="code" href="group__xgTcpSocket.html#ga15">NutTcpError</a>(sock);
     <a class="code" href="group__xgCrtStdio.html#ga36">printf</a>(<span class="stringliteral">"TCP Error: "</span>);
     <span class="keywordflow">switch</span>(tcperr) {
     <span class="keywordflow">case</span> <a class="code" href="net_2errno_8h.html#a31">EHOSTUNREACH</a>:
         <a class="code" href="group__xgCrtStdio.html#ga36">printf</a>(<span class="stringliteral">"No route to %s\n"</span>, <a class="code" href="group__xgIP.html#ga9">inet_ntoa</a>(ip));
         <span class="keywordflow">break</span>;
     <span class="keywordflow">default</span>:
         <a class="code" href="group__xgCrtStdio.html#ga36">printf</a>(<span class="stringliteral">"%d\n"</span>, tcperr);
         <span class="keywordflow">break</span>;
     }
 }
</pre></div>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcp__socket.html">tcp_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TCP socket information structure.  <a href="structtcp__socket.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga21"></a><!-- doxytag: member="xgTcpSocket::SO_FIN" ref="ga21" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga21">SO_FIN</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket transmit flag. Send FIN after all data has been transmitted. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga22"></a><!-- doxytag: member="xgTcpSocket::SO_SYN" ref="ga22" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga22">SO_SYN</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket transmit flag. Send SYN first. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga23"></a><!-- doxytag: member="xgTcpSocket::SO_FORCE" ref="ga23" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga23">SO_FORCE</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket transmit flag. Force sending ACK. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga24"></a><!-- doxytag: member="xgTcpSocket::SO_ACK" ref="ga24" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga24">SO_ACK</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket transmit flag. Send ACK. <br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga0"></a><!-- doxytag: member="xgTcpSocket::TCPSOCKET" ref="ga0" args="" -->
typedef <a class="el" href="structtcp__socket.html">tcp_socket</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga0">TCPSOCKET</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TCP socket type. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga4"></a><!-- doxytag: member="xgTcpSocket::NutTcpDiscardBuffers" ref="ga4" args="(TCPSOCKET *sock)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>NutTcpDiscardBuffers</b> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga5">NutTcpDestroySocket</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a previously allocated socket.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga6">NutTcpFindSocket</a> (<a class="el" href="group__xgNutOS.html#ga1">u_short</a> lport, <a class="el" href="group__xgNutOS.html#ga1">u_short</a> rport, <a class="el" href="group__xgNutOS.html#ga3">u_long</a> raddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a matching socket.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a TCP socket.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga8">NutTcpSetSockOpt</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock, int optname, CONST void *optval, int optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set value of a TCP socket option.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga9">NutTcpGetSockOpt</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock, int optname, void *optval, int optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a TCP socket option value.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga10">NutTcpConnect</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock, <a class="el" href="group__xgNutOS.html#ga3">u_long</a> addr, <a class="el" href="group__xgNutOS.html#ga1">u_short</a> port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to a remote socket.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga11">NutTcpAccept</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock, <a class="el" href="group__xgNutOS.html#ga1">u_short</a> port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for incoming connect from a remote socket.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga12">NutTcpSend</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock, CONST void *data, <a class="el" href="group__xgNutOS.html#ga1">u_short</a> len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send data on a connected TCP socket.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga13">NutTcpReceive</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock, void *data, <a class="el" href="group__xgNutOS.html#ga1">u_short</a> size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive data on a connected TCP socket.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga14">NutTcpCloseSocket</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close TCP socket.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga15">NutTcpError</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return specific code of the last error.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga16">NutTcpDeviceRead</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock, void *buffer, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from virtual socket device.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga18">NutTcpDeviceWrite</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock, CONST void *buf, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a socket.  <a href="#ga18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga19">NutTcpDeviceWrite_P</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock, PGM_P buffer, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to device.  <a href="#ga19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga20">NutTcpDeviceIOCtl</a> (<a class="el" href="structtcp__socket.html">TCPSOCKET</a> *sock, int cmd, void *param)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Driver control function.  <a href="#ga20"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgTcpSocket.html#ga1">tcpSocketList</a> = 0</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga5"></a><!-- doxytag: member="tcpsock.c::NutTcpDestroySocket" ref="ga5" args="(TCPSOCKET *sock)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutTcpDestroySocket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy a previously allocated socket. 
<p>
Remove socket from the socket list and release occupied memory.<p>
Applications must not call this function. It is automatically called by a timer after the socket has been closed by <a class="el" href="group__xgTcpSocket.html#ga14">NutTcpCloseSocket()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6"></a><!-- doxytag: member="tcpsock.c::NutTcpFindSocket" ref="ga6" args="(u_short lport, u_short rport, u_long raddr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a>* NutTcpFindSocket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__xgNutOS.html#ga1">u_short</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lport</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__xgNutOS.html#ga1">u_short</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rport</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__xgNutOS.html#ga3">u_long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>raddr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find a matching socket. 
<p>
Loop through all sockets and find a matching connection (prefered) or a listening socket.<p>
Applications typically do not call this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lport</em>&nbsp;</td><td>Local port number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rport</em>&nbsp;</td><td>Remote port number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>raddr</em>&nbsp;</td><td>Remote IP address in network byte order.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Socket descriptor.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7"></a><!-- doxytag: member="tcpsock.c::NutTcpCreateSocket" ref="ga7" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a>* NutTcpCreateSocket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a TCP socket. 
<p>
Allocates a TCPSOCKET structure from heap memory, initializes it and returns a pointer to that structure.<p>
The very first call will also start the TCP state machine, which is running in a separate thread.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Socket descriptor of the newly created TCP socket or 0 if there is not enough memory left.</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd>Avoid fixed initial sequence number. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8"></a><!-- doxytag: member="tcpsock.c::NutTcpSetSockOpt" ref="ga8" args="(TCPSOCKET *sock, int optname, CONST void *optval, int optlen)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpSetSockOpt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>CONST void *&nbsp;</td>
          <td class="mdname" nowrap> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>optlen</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set value of a TCP socket option. 
<p>
The following values can be set:<p>
<ul>
<li><a class="el" href="netinet_2tcp_8h.html#a21">TCP_MAXSEG</a> Maximum segment size (<a class="el" href="group__xgNutOS.html#ga1">u_short</a>). Can only be set if socket is not yet connected.</li><li><a class="el" href="socket_8h.html#a17">SO_SNDTIMEO</a> Socket send timeout (<a class="el" href="group__xgNutOS.html#ga3">u_long</a>).</li><li><a class="el" href="socket_8h.html#a18">SO_RCVTIMEO</a> Socket receive timeout (<a class="el" href="group__xgNutOS.html#ga3">u_long</a>).</li><li><a class="el" href="socket_8h.html#a13">SO_SNDBUF</a> Socket output buffer size (<a class="el" href="group__xgNutOS.html#ga1">u_short</a>).</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>Option to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length of the value. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. The specific error code can be retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga15">NutTcpError()</a>.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9"></a><!-- doxytag: member="tcpsock.c::NutTcpGetSockOpt" ref="ga9" args="(TCPSOCKET *sock, int optname, void *optval, int optlen)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpGetSockOpt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>optlen</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a TCP socket option value. 
<p>
The following values can be set:<p>
<ul>
<li><a class="el" href="netinet_2tcp_8h.html#a21">TCP_MAXSEG</a> Maximum segment size (<a class="el" href="group__xgNutOS.html#ga1">u_short</a>).</li><li><a class="el" href="socket_8h.html#a17">SO_SNDTIMEO</a> Socket send timeout (<a class="el" href="group__xgNutOS.html#ga3">u_long</a>).</li><li><a class="el" href="socket_8h.html#a18">SO_RCVTIMEO</a> Socket receive timeout (<a class="el" href="group__xgNutOS.html#ga3">u_long</a>).</li><li><a class="el" href="socket_8h.html#a13">SO_SNDBUF</a> Socket output buffer size (<a class="el" href="group__xgNutOS.html#ga1">u_short</a>).</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>Option to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Points to a buffer receiving the value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length of the value buffer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. The specific error code can be retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga15">NutTcpError()</a>.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10"></a><!-- doxytag: member="tcpsock.c::NutTcpConnect" ref="ga10" args="(TCPSOCKET *sock, u_long addr, u_short port)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpConnect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__xgNutOS.html#ga3">u_long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__xgNutOS.html#ga1">u_short</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>port</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Connect to a remote socket. 
<p>
This function tries to establish a connection to the specified remote port of the specified remote server. The calling thread will be suspended until a connection is successfully established or an error occurs.<p>
This function is typically used by TCP client applications.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>IP address of the host to connect (network byte order). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port number to connect (host byte order).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. The specific error code can be retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga15">NutTcpError()</a>.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11"></a><!-- doxytag: member="tcpsock.c::NutTcpAccept" ref="ga11" args="(TCPSOCKET *sock, u_short port)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpAccept           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__xgNutOS.html#ga1">u_short</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>port</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for incoming connect from a remote socket. 
<p>
The calling thread will be suspended until until an incoming connection request is received.<p>
This function is typically used by TCP server applications.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port number to listen to (host byte order).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. The specific error code can be retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga15">NutTcpError()</a>.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12"></a><!-- doxytag: member="tcpsock.c::NutTcpSend" ref="ga12" args="(TCPSOCKET *sock, CONST void *data, u_short len)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpSend           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>CONST void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__xgNutOS.html#ga1">u_short</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send data on a connected TCP socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>. In addition a connection must have been established by calling NutTcpConnect or NutTcpAccept. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Pointer to a buffer containing the data to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Number of bytes to be sent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>If successful, the number of bytes added to the socket transmit buffer. This is limited to the maximum segment size of the connection and thus may be less than the specified number of bytes to send. The return value -1 indicates a fatal error. On time out, a value of 0 is returned.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13"></a><!-- doxytag: member="tcpsock.c::NutTcpReceive" ref="ga13" args="(TCPSOCKET *sock, void *data, u_short size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpReceive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__xgNutOS.html#ga1">u_short</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive data on a connected TCP socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>. In addition a connection must have been established by calling NutTcpConnect or NutTcpAccept. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Pointer to the buffer that receives the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the buffer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>If successful, the number of received data bytes is returned. This may be less than the specified size of the buffer. The return value 0 indicates a timeout, while -1 is returned in case of an error or broken connection. Call <a class="el" href="group__xgTcpSocket.html#ga15">NutTcpError()</a> to determine the specific error code.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14"></a><!-- doxytag: member="tcpsock.c::NutTcpCloseSocket" ref="ga14" args="(TCPSOCKET *sock)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpCloseSocket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close TCP socket. 
<p>
Note, that the socket may not be immediately destroyed after calling this function. However, the application must not use the socket after this call.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15"></a><!-- doxytag: member="tcpsock.c::NutTcpError" ref="ga15" args="(TCPSOCKET *sock)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpError           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return specific code of the last error. 
<p>
Possible error codes (net/errno.h) are:<p>
<ul>
<li>EWOULDBLOCK: Operation would block</li><li>EINPROGRESS: Operation now in progress</li><li>EALREADY: Operation already in progress</li><li>ENOTSOCK: Socket operation on non-socket</li><li>EDESTADDRREQ: Destination address required</li><li>EMSGSIZE: Message too long</li><li>EPROTOTYPE: Protocol wrong type for socket</li><li>ENOPROTOOPT: Protocol not available</li><li>EPROTONOSUPPORT: Protocol not supported</li><li>ESOCKTNOSUPPORT: Socket type not supported</li><li>EOPNOTSUPP: Operation not supported on socket</li><li>EPFNOSUPPORT: Protocol family not supported</li><li>EAFNOSUPPORT: Address family not supported by protocol family</li><li>EADDRINUSE: Address already in use</li><li>EADDRNOTAVAIL: Can't assign requested address</li><li>ENETDOWN: Network is down</li><li>ENETUNREACH: Network is unreachable</li><li>ENETRESET: Network dropped connection on reset</li><li>ECONNABORTED: Software caused connection abort</li><li>ECONNRESET: Connection reset by peer</li><li>ENOBUFS: No buffer space available</li><li>EISCONN: Socket is already connected</li><li>ENOTCONN: Socket is not connected</li><li>ESHUTDOWN: Can't send after socket shutdown</li><li>ETOOMANYREFS: Too many references: can't splice</li><li>ETIMEDOUT: Connection timed out</li><li>ECONNREFUSED: Connection refused</li><li>ELOOP: Too many levels of symbolic links</li><li>ENAMETOOLONG: File name too long</li><li>EHOSTDOWN: Host is down</li><li>EHOSTUNREACH: No route to host</li><li>ENOTEMPTY: Directory not empty</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>Applications must not call this function to retrieve the error code if <a class="el" href="group__xgTcpSocket.html#ga14">NutTcpCloseSocket()</a> or <a class="el" href="group__xgTcpSocket.html#ga5">NutTcpDestroySocket()</a> failed.</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd>Not all error codes are properly set right now. Some socket functions return an error without setting an error code. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16"></a><!-- doxytag: member="tcpsock.c::NutTcpDeviceRead" ref="ga16" args="(TCPSOCKET *sock, void *buffer, int size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpDeviceRead           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read from virtual socket device. 
<p>
TCP sockets can be used like other Nut/OS devices. This routine is part of the virtual socket device driver.<p>
This function is called by the low level input routines of the <a class="el" href="group__xgCrtLowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct__NUTDEVICE.html#o9">_NUTDEVICE::dev_read</a> entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to the buffer that receives the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Maximum number of bytes to read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read, which may be less than the number of bytes specified. A return value of -1 indicates an error, while zero is returned in case of a timeout.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga18"></a><!-- doxytag: member="tcpsock.c::NutTcpDeviceWrite" ref="ga18" args="(TCPSOCKET *sock, CONST void *buf, int size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpDeviceWrite           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>CONST void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write to a socket. 
<p>
TCP sockets can be used like other Nut/OS devices. This routine is part of the virtual socket device driver.<p>
This function is called by the low level output routines of the <a class="el" href="group__xgCrtLowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct__NUTDEVICE.html#o10">_NUTDEVICE::dev_write</a> entry.<p>
In contrast to <a class="el" href="group__xgTcpSocket.html#ga12">NutTcpSend()</a> this routine provides some buffering.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Pointer to the data to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Number of bytes to write. If zero, then the output buffer will be flushed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written. A return value of -1 indicates an error.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga19"></a><!-- doxytag: member="tcpsock.c::NutTcpDeviceWrite_P" ref="ga19" args="(TCPSOCKET *sock, PGM_P buffer, int size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpDeviceWrite_P           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>PGM_P&nbsp;</td>
          <td class="mdname" nowrap> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write to device. 
<p>
This function is implemented for CPUs with Harvard Architecture only.<p>
TCP sockets can be used like other Nut/OS devices. This routine is part of the virtual socket device driver and similar to <a class="el" href="group__xgTcpSocket.html#ga18">NutTcpDeviceWrite()</a> except that the data is located in program memory.<p>
This function is called by the low level output routines of the <a class="el" href="group__xgCrtLowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct__NUTDEVICE.html#o11">_NUTDEVICE::dev_write_P</a> entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to the data in program space to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Number of bytes to write.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd>Inefficient implementation. No buffering has been implemented. Thus, each call will result in a separate TCP segment.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga20"></a><!-- doxytag: member="tcpsock.c::NutTcpDeviceIOCtl" ref="ga20" args="(TCPSOCKET *sock, int cmd, void *param)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int NutTcpDeviceIOCtl           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>param</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Driver control function. 
<p>
Used by the virtual device driver to modify or query device specific settings.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xgTcpSocket.html#ga7">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd</em>&nbsp;</td><td>Requested control function. May be set to one of the following constants:<ul>
<li><a class="el" href="group__xgCrtLowio.html#ga27">IOCTL_GETFILESIZE</a></li><li><a class="el" href="group__xgCrtLowio.html#ga29">IOCTL_GETINBUFCOUNT</a></li><li><a class="el" href="group__xgCrtLowio.html#ga28">IOCTL_GETOUTBUFCOUNT</a></li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>Points to a buffer that contains any data required for the given control function or receives data from that function. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise.</dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="ga1"></a><!-- doxytag: member="tcpsock.c::tcpSocketList" ref="ga1" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structtcp__socket.html">TCPSOCKET</a>* <a class="el" href="group__xgTcpSocket.html#ga1">tcpSocketList</a> = 0          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Global linked list of all TCP sockets.     </td>
  </tr>
</table>
<hr>
<address>
  <small>
    &copy;&nbsp;2000-2006 by egnite Software GmbH - 
    visit <a href="http://www.ethernut.de/">http://www.ethernut.de/</a>
  </small>
</address>
</body>
</html>
