<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Nut/OS API</title>
    <link href="nut_en.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>Thread Management<br>
<small>
[<a class="el" href="group__xgNutOS.html">Nut/OS API</a>]</small>
</h1>
<p>
Collaboration diagram for Thread Management:<center><table><tr><td><img src="group__xgThread.png" border="0" alt="" usemap="#group____xgThread_map">
<map name="group____xgThread_map">
<area href="group__xgNutOS.html" shape="rect" coords="17,5,95,26" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Cooperative multi-threading support. 
<p>
<a class="anchor" name="xrThread"></a><p>
Typically Nut/OS is at its most useful where there are several concurrent tasks that need to be undertaken at the same time. To support this requirement, Nut/OS offers some kind of light processes called threads. In this context a thread is a sequence of executing software that can be considered to be logically independent from other software that is running on the same CPU.<p>
All threads are executing in the same address space using the same hardware resources, which significantly reduces task switching overhead. Therefore it is important to stop them from causing each other problems. This is particularly an issue where two or more threads need to share a resources like memory locations or peripheral devices.<p>
The system works on the principle that the most urgent thread always runs. One exception to this is if a CPU interrupt arrives and the interrupt has not been disabled. Each thread has a priority which is used to determine how urgent it is. This priority ranges from 0 to 255, with the lowest value indicating the most urgent.<p>
Nut/OS implements cooperative multithreading. That means, that threads are not bound to a fixed timeslice. Unless they are waiting for specific event or explicitely yielding the CPU, they can rely on not being stopped unexpectedly. However, they may be interrupted by hardware interrupt signals. In opposite to pre-emptive multithreading, coorperative multithreading simplifies resource sharing and results in faster and smaller code.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Using the special priority 255 to kill a thread is not required and should be removed.</dd></dl>
To specify a function named Back as an independant thread, one can write <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="thread_8h.html">sys/thread.h</a>&gt;</span>

 <a class="code" href="thread_8h.html#a6">THREAD</a>(Back, arg)
 {
     <span class="keywordflow">for</span> (;;) {
         <a class="code" href="group__xgTimer.html#ga10">NutSleep</a>(1000);
     }
 } 
</pre></div><p>
To start this thread, use <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="thread_8h.html">sys/thread.h</a>&gt;</span>

  Other code here... 

 <a class="code" href="group__xgNutArchAvrOsContextGcc.html#ga2">NutThreadCreate</a>(<span class="stringliteral">"Bg"</span>, Back, NULL, 512);
  Execution continues here and concurrently in the background thread.
</pre></div><p>
The functions listed below are hardware independant. Additional API calls are located in the architecture dependant sections.<ul>
<li><a class="el" href="group__xgNutArchAvrOsContextGcc.html">AVR with GNU Compiler</a></li><li><a class="el" href="group__xgNutArchAvrOsContextGcc.html">AVR with ImageCraft Compiler</a></li><li><a class="el" href="group__xgNutArchArmOsContext.html">ARM</a></li><li><a class="el" href="group__xgNutArchUnixOsContext.html">Emulator (UNIX)</a></li></ul>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__NUTTHREADINFO.html">_NUTTHREADINFO</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread information structure.  <a href="struct__NUTTHREADINFO.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__NUTTHREADINFO.html">_NUTTHREADINFO</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread information structure.  <a href="struct__NUTTHREADINFO.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="struct__NUTTHREADINFO.html">_NUTTHREADINFO</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga0">NUTTHREADINFO</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga5">NutThreadAddPriQueue</a> (<a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *td, <a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *volatile *tqpp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a thread to a prioritiy ordered queue.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga6">NutThreadRemoveQueue</a> (<a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *td, <a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *volatile *tqpp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a thread from a specified queue.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga7">NutThreadResume</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Continue with the highest priority thread, which is ready to run.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga8">NutThreadWake</a> (<a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> timer, <a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> th)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume a previously suspended thread.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga9">NutThreadYield</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give up the CPU.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u_char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga10">NutThreadSetPriority</a> (u_char level)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the current thread's priority.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga11">NutThreadExit</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End the current thread.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga12">NutThreadDestroy</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a thread that was previously killed and release memory back to the OS.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga13">NutThreadKill</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill the running thread.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__xgNutOS.html#ga5">HANDLE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga14">GetThreadByName</a> (char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query handle of a thread with a specific name.  <a href="#ga14"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga1">runningThread</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Currently running thread.  <a href="#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga2">killedThread</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread to be killed.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga3">nutThreadList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of all created threads.  <a href="#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xgThread.html#ga4">runQueue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of ready-to-run threads.  <a href="#ga4"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga0"></a><!-- doxytag: member="thread.h::NUTTHREADINFO" ref="ga0" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct <a class="el" href="struct__NUTTHREADINFO.html">_NUTTHREADINFO</a> <a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Thread information structure type.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga5"></a><!-- doxytag: member="thread.c::NutThreadAddPriQueue" ref="ga5" args="(NUTTHREADINFO *td, NUTTHREADINFO *volatile *tqpp)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutThreadAddPriQueue           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>td</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *volatile *&nbsp;</td>
          <td class="mdname" nowrap> <em>tqpp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a thread to a prioritiy ordered queue. 
<p>
Insert the thread into a specified queue behind the last thread with lower or equal priority.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>td</em>&nbsp;</td><td>Pointer to NUTTHREADINFO of the thread to be inserted in the queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tqpp</em>&nbsp;</td><td>Pointer to the root of the queue.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6"></a><!-- doxytag: member="thread.c::NutThreadRemoveQueue" ref="ga6" args="(NUTTHREADINFO *td, NUTTHREADINFO *volatile *tqpp)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutThreadRemoveQueue           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>td</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a> *volatile *&nbsp;</td>
          <td class="mdname" nowrap> <em>tqpp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a thread from a specified queue. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Depending on the given queue, CPU interrupts must have been disabled before calling this function.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>td</em>&nbsp;</td><td>Pointer to NUTTHREADINFO of the thread to be removed from the queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tqpp</em>&nbsp;</td><td>Pointer to the root of the queue.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7"></a><!-- doxytag: member="thread.c::NutThreadResume" ref="ga7" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutThreadResume           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Continue with the highest priority thread, which is ready to run. 
<p>
If the currently running thread lost its top position in the queue of ready-to-run threads, then the context will be switched.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000030">Todo:</a></b></dt><dd>Removing a single thread from a wait queue only improves context switching, but may result in an event time-out for remaining threads, although events had been posted already. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8"></a><!-- doxytag: member="thread.c::NutThreadWake" ref="ga8" args="(HANDLE timer, HANDLE th)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutThreadWake           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__xgNutOS.html#ga5">HANDLE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__xgNutOS.html#ga5">HANDLE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resume a previously suspended thread. 
<p>
This routine is called by the system when a sleep timer elapses.<p>
<dl compact><dt><b>Note:</b></dt><dd>This routine is used as a timer callback for NutSleep implementation Applications typically do not call this function.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>Handle of the elapsed timer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>Handle of the thread to wake up.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd>Used by the timer module. Should be moved there, because not all applications will use of <a class="el" href="group__xgTimer.html#ga10">NutSleep()</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9"></a><!-- doxytag: member="thread.c::NutThreadYield" ref="ga9" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutThreadYield           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Give up the CPU. 
<p>
If another thread within the same or higher priority is ready to run, then the current thread is stopped and the other one is started.    </td>
  </tr>
</table>
<a class="anchor" name="ga10"></a><!-- doxytag: member="thread.c::NutThreadSetPriority" ref="ga10" args="(u_char level)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u_char NutThreadSetPriority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_char&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>level</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the current thread's priority. 
<p>
The priority of newly created threads is set to 64, but may be changed when the thread starts running.<p>
Changing the priority level to 255 will kill the calling thread.<p>
When another thread with a higher or equal priority is ready to run, the current thread will be stopped and control of the CPU is passed to the other thread.<p>
The function returns the old priority, which makes it easy to temporarily switch to another priority and later set back the old one.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>New priority level or 255 to kill the thread. Zero specifies the highest priority. The idle thread is running at level 254 (lowest priority). Application threads should use levels from 32 to 253.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The old priority of this thread.</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000032">Todo:</a></b></dt><dd>Using a specific priority level for killing a thread is actually not the best idea. <a class="el" href="group__xgThread.html#ga13">NutThreadKill()</a> can be used instead. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11"></a><!-- doxytag: member="thread.c::NutThreadExit" ref="ga11" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutThreadExit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
End the current thread. 
<p>
Terminates the current thread, in due course the memory associated with the thread will be released back to the OS this is done by the idle thread.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000033">Todo:</a></b></dt><dd><a class="el" href="group__xgThread.html#ga13">NutThreadKill()</a> can be used instead of setting the priority level to 255. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12"></a><!-- doxytag: member="thread.c::NutThreadDestroy" ref="ga12" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutThreadDestroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a thread that was previously killed and release memory back to the OS. 
<p>
Called when another thread is killed and by the idle thread.<p>
Applications generally do not call this function, however you could call it to try to reclaim memory.    </td>
  </tr>
</table>
<a class="anchor" name="ga13"></a><!-- doxytag: member="thread.c::NutThreadKill" ref="ga13" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NutThreadKill           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Kill the running thread. 
<p>
The thread is moved from the schedule que and<p>
Applications generally do not call this function.    </td>
  </tr>
</table>
<a class="anchor" name="ga14"></a><!-- doxytag: member="thread.c::GetThreadByName" ref="ga14" args="(char *name)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__xgNutOS.html#ga5">HANDLE</a> GetThreadByName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Query handle of a thread with a specific name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Case sensitive symbolic name of the thread.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Handle of the thread, if it exists. Otherwise NULL is returned.</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd>Rarely used helper function. Should be placed in a seperate module. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="ga1"></a><!-- doxytag: member="thread.c::runningThread" ref="ga1" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a>* <a class="el" href="group__xgThread.html#ga1">runningThread</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Currently running thread. 
<p>
Pointer to the NUTTHREADINFO structure of the currently running thread.    </td>
  </tr>
</table>
<a class="anchor" name="ga2"></a><!-- doxytag: member="thread.c::killedThread" ref="ga2" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a>* <a class="el" href="group__xgThread.html#ga2">killedThread</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Thread to be killed. 
<p>
Pointer to the NUTTHREADINFO structure of the latest killed thread.    </td>
  </tr>
</table>
<a class="anchor" name="ga3"></a><!-- doxytag: member="thread.c::nutThreadList" ref="ga3" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a>* <a class="el" href="group__xgThread.html#ga3">nutThreadList</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
List of all created threads. 
<p>
Linked list of NUTTHREADINFO structures of all threads. New threads are put in front. This list contains at least two threads, the main application thread followed by the idle thread.    </td>
  </tr>
</table>
<a class="anchor" name="ga4"></a><!-- doxytag: member="thread.c::runQueue" ref="ga4" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="struct__NUTTHREADINFO.html">NUTTHREADINFO</a>* <a class="el" href="group__xgThread.html#ga4">runQueue</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
List of ready-to-run threads. 
<p>
Priority ordered linked list of NUTTHREADINFO structures of all threads which are ready to run. The idle thread will always remain at the end of this list.    </td>
  </tr>
</table>
<hr>
<address>
  <small>
    &copy;&nbsp;2000-2006 by egnite Software GmbH - 
    visit <a href="http://www.ethernut.de/">http://www.ethernut.de/</a>
  </small>
</address>
</body>
</html>
